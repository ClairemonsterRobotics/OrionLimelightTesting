// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc5474.Orion.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc5474.Orion.Robot;
import edu.wpi.first.wpilibj.Timer;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/**
 *
 */
public class tractionDrive extends Command {


    private Timer driveTimer;
    private int timeState;
    private final static int TIME_STATE_LIFT = 1;
    private final static int TIME_STATE_PULL_IN = 2;
    private final static int TIME_STATE_GRAB_HOLD = 3;
    private final static int TIME_STATE_PULL_UP = 4;
    private double startDriveDistance = 0;
    private double startWinchDistance = 0;
    private double finalWinchDistance = 46;
    private double finalDriveDistance = 46;
    double time;
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public tractionDrive() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveSub);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
    }

    private void changeTimeState(int nextState){
        if (nextState != timeState){
            timeState = nextState;
            driveTimer.reset();
        }
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
        startDriveDistance = Robot.driveSub.GetandPutDistance();

        timeState = TIME_STATE_LIFT;
		driveTimer = new Timer();
		driveTimer.start();
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
        double currentDriveDistance = 0;
        double currentWinchDistance = 0;
        SmartDashboard.putNumber("State", timeState);
        
        switch (timeState){

            case TIME_STATE_LIFT: {
                time = 2;
                Robot.driveSub.driveStraight(0.9);
                currentDriveDistance = Robot.driveSub.GetandPutDistance() - startDriveDistance;
                SmartDashboard.putNumber("Lift state drive distance", currentDriveDistance);


                if (driveTimer.hasPeriodPassed(time)){
                    changeTimeState(TIME_STATE_PULL_IN);
                }
            }

            case TIME_STATE_PULL_IN: {
                time = 5;
                currentWinchDistance = Robot.driveSub.GetandPutDistance() - startWinchDistance;
                SmartDashboard.putNumber("Pull in state winch distance", currentWinchDistance);

                if (driveTimer.hasPeriodPassed(time)){
                    changeTimeState(TIME_STATE_GRAB_HOLD);
                }
            }

            case TIME_STATE_GRAB_HOLD: {
                time = 2.5;
                Robot.driveSub.driveStraight(0.4);
                SmartDashboard.putNumber("Grab hold state winch distance", currentWinchDistance);
                currentDriveDistance = Robot.driveSub.GetandPutDistance() - currentDriveDistance;
                SmartDashboard.putNumber("Grab hold state drive distance", currentDriveDistance);

                while(currentWinchDistance < finalWinchDistance) {
                }

                if (driveTimer.hasPeriodPassed(time)){
                    changeTimeState(TIME_STATE_PULL_UP);
                }
            }

            case TIME_STATE_PULL_UP: {
                time = 4;
                Robot.driveSub.driveStraight(0.6);
                SmartDashboard.putNumber("Pull up state drive distance", currentDriveDistance);

                while(currentDriveDistance < finalDriveDistance) {
                    Robot.driveSub.driveStraight(0.1);
                }

                if (driveTimer.hasPeriodPassed(time)){
                    end();
                }
            }

        break;
        }
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
        cancel();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    }
}
